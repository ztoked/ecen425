#include "clib.h"
#include "yakk.h"
#include "lab6defs.h"

extern int KeyBuffer;
extern int NewPieceID;
extern int NewPieceType;
extern int NewPieceOrientation;
extern int NewPieceColumn;
extern YKQ *PieceQPtr;
extern struct piece pieceArray[];
extern YKSEM *commandSem;

/*
 *        void newPieceHandler()
 *Indicates that a new piece has appeared on the board. When this
 *interrupt occurs, information can be obtained about the pieces
 *by reading variables declared in clib.s. The ID of the new piece
 *(required as a parameter in the functions that move pieces) is
 *stored in NewPieceID, the type of piece is stored in
 *NewPieceType, its orientation is stored in NewPieceOrientation,
 *and its column (the corner block on corner pieces and the center
 *block on straight pieces) is in NewPieceColumn. The row for new
 *pieces is always row 14. More details on accessing and
 *interpreting these variables will be given shortly.
 */
void newPieceHandler()
{
	static int next = 0;

  pieceArray[next].id = NewPieceID;
  pieceArray[next].type = NewPieceType;
  pieceArray[next].orientation = NewPieceOrientation;
  pieceArray[next].column = NewPieceColumn;

  if (YKQPost(PieceQPtr, (void *) &(pieceArray[next])) == 0)
	{
		printString("TickISR: queue overflow!\n");
	}
  else if (++next >= PIECEARRAYSIZE)
	{
		next = 0;
	}
}

/*
 *        void receivedCommandHandler()
 *This indicates that Simptris received the last command that was
 *sent and that a new command (shift or rotate) can be sent. This
 *interrupt is generated by the simulator after a fixed delay from
 *the sending of the previous command. You should never send a
 *command until this interrupt has been received for the previous
 *command; if you do, your second command will overwrite the
 *parameters of the first and just generally mess things up. You
 *should not interpret this interrupt as an indication that the
 *previous command was executed successfully; for example, if you
 *try to rotate a straight piece that is against the side, nothing
 *will happen, but you will still get this interrupt after the
 *specified delay indicating that the "channel" is clear to send
 *the next command.
 */
void receivedCommandHandler()
{
  YKSemPost(commandSem);
}

/*
 *        void touchdownHandler()
 *This indicates that a piece has landed on something and therefore
 *stopped falling. The ID of the piece is found in the global variable
 *TouchdownID. Each time this interrupt occurs, a bitmap of the new
 *screen after the touchdown (ignoring pieces that are still falling)
 *is contained in the word sized variables ScreenBitMap0,
 *ScreenBitMap1, ScreenBitMap2, ScreenBitMap3, ScreenBitMap4, and
 *ScreenBitMap5. Each of these represents (in order from left to right)
 *one column. Of the 16-bits in each variable, the MSB corresponds to
 *the lowest row, and the LSB corresponds the highest row. A bit value
 *of 1 means that the corresponding square on the game board is
 *occupied and a 0 means that the space is vacant.
 */
void touchdownHandler()
{
}

/*
 *        void lineClearHandler()
 *This indicates that a line has been cleared in Simptris. If a piece
 *cleared more than one line, only one interrupt is generated.
 */
void lineClearHandler()
{
}

/*
 *        void gameoverHandler()
 *Indicates that the game is over. No new pieces will appear.
 */
void gameoverHandler()
{
  printString("GAMEOVER\n");
  exit(0);
}

void tickHandler()
{

}

void keyboardHandler()
{
}
