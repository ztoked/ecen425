; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
FLAGS_MASK:
	DW	512
YKInterruptDepth:
	DW	0
kernelStarted:
	DW	0
readyToStart:
	DB	0
runningTask:
	DB	0
firstTime:
	DB	1
	ALIGN	2
pushedLevel:
	DW	0
contextSaved:
	DB	0
	ALIGN	2
semIndex:
	DW	0
qIndex:
	DW	0
eventIndex:
	DW	0
	ALIGN	2
YKInitialize:
	; >>>>> Line:	39
	; >>>>> { 
	jmp	L_yakc_1
L_yakc_2:
	; >>>>> Line:	41
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	43
	; >>>>> for (i = 0; i < 5; ++i) 
	mov	word [bp-2], 0
	jmp	L_yakc_4
L_yakc_3:
	; >>>>> Line:	45
	; >>>>> YKTCBArray[i].priority = 100; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	byte [si], 100
	; >>>>> Line:	46
	; >>>>> YKTCBArray[i].inUse = 0; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	byte [si], 0
L_yakc_6:
	inc	word [bp-2]
L_yakc_4:
	cmp	word [bp-2], 5
	jl	L_yakc_3
L_yakc_5:
	; >>>>> Line:	49
	; >>>>> YKNewTask(YKIdleTask, (void *)&IdleStk[256], 99); 
	mov	al, 99
	push	ax
	mov	ax, (IdleStk+512)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	50
	; >>>>> r 
	mov	byte [readyToStart], 0
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_2
L_yakc_8:
	DB	"Pushed: ",0
	ALIGN	2
pushed:
	; >>>>> Line:	53
	; >>>>> { 
	jmp	L_yakc_9
L_yakc_10:
	; >>>>> Line:	54
	; >>>>> pushedLevel = pushedLevel + 1; 
	mov	ax, word [pushedLevel]
	inc	ax
	mov	word [pushedLevel], ax
	; >>>>> Line:	55
	; >>>>> printString("Pushed: "); 
	mov	ax, L_yakc_8
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	56
	; >>>>> printInt(pushedLevel); 
	push	word [pushedLevel]
	call	printInt
	add	sp, 2
	; >>>>> Line:	57
	; >>>>> printNewLine(); 
	call	printNewLine
	mov	sp, bp
	pop	bp
	ret
L_yakc_9:
	push	bp
	mov	bp, sp
	jmp	L_yakc_10
L_yakc_12:
	DB	"Popped: ",0
	ALIGN	2
popped:
	; >>>>> Line:	61
	; >>>>> { 
	jmp	L_yakc_13
L_yakc_14:
	; >>>>> Line:	62
	; >>>>> pushedLevel = pushedLevel - 1; 
	mov	ax, word [pushedLevel]
	dec	ax
	mov	word [pushedLevel], ax
	; >>>>> Line:	63
	; >>>>> printString("Popped: "); 
	mov	ax, L_yakc_12
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	64
	; >>>>> printInt(pushedLevel); 
	push	word [pushedLevel]
	call	printInt
	add	sp, 2
	; >>>>> Line:	65
	; >>>>> printNewLine(); 
	call	printNewLine
	mov	sp, bp
	pop	bp
	ret
L_yakc_13:
	push	bp
	mov	bp, sp
	jmp	L_yakc_14
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	69
	; >>>>> { 
	jmp	L_yakc_16
L_yakc_17:
	; >>>>> Line:	70
	; >>>>> while(1) 
	jmp	L_yakc_19
L_yakc_18:
	; >>>>> Line:	72
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	73
	; >>>>> ++YKIdleCount; 
	inc	word [YKIdleCount]
	; >>>>> Line:	74
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_19:
	jmp	L_yakc_18
L_yakc_20:
	mov	sp, bp
	pop	bp
	ret
L_yakc_16:
	push	bp
	mov	bp, sp
	jmp	L_yakc_17
	ALIGN	2
YKNewTask:
	; >>>>> Line:	79
	; >>>>> { 
	jmp	L_yakc_22
L_yakc_23:
	; >>>>> Line:	81
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	83
	; >>>>> for (i = 0; i <= 5; ++i) 
	mov	word [bp-2], 0
	jmp	L_yakc_25
L_yakc_24:
	; >>>>> Line:	85
	; >>>>> if (!YKTCBArray[i].inUse) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_28
	; >>>>> Line:	86
	; >>>>> nte 
	jmp	L_yakc_26
L_yakc_28:
L_yakc_27:
	inc	word [bp-2]
L_yakc_25:
	cmp	word [bp-2], 5
	jle	L_yakc_24
L_yakc_26:
	; >>>>> Line:	89
	; >>>>> YKTCBArray[i].ip = (unsigned int) task; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	mov	si, ax
	add	si, YKTCBArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	90
	; >>>>> YKTCBArray[i].stackptr = taskStack; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	91
	; >>>>> YKTCBArray[i].state = READY; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 3
	; >>>>> Line:	92
	; >>>>> YKTCBArray[i].delay = 0; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	93
	; >>>>> YKTCBArray[i].inUse = 1; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	byte [si], 1
	; >>>>> Line:	94
	; >>>>> YKTCBArray[i].priority = priority; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	al, byte [bp+8]
	mov	byte [si], al
	; >>>>> Line:	95
	; >>>>> YKCreateContext(YKTCBArray[i].stackptr, YKTCBArray[i].ip); 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	mov	si, ax
	add	si, YKTCBArray
	push	word [si]
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 2
	push	word [si]
	call	YKCreateContext
	add	sp, 4
	; >>>>> Line:	96
	; >>>>> YKTCBArray[i].stackptr += 24; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 2
	add	word [si], -24
	; >>>>> Line:	97
	; >>>>> readyToStart = 1; 
	mov	byte [readyToStart], 1
	; >>>>> Line:	99
	; >>>>> if(kernelStarted) 
	mov	ax, word [kernelStarted]
	test	ax, ax
	je	L_yakc_29
	; >>>>> Line:	101
	; >>>>> currentTask = &YKTCBArray[i]; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	word [currentTask], ax
	; >>>>> Line:	102
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	103
	; >>>>> YKScheduler(); 
	call	YKScheduler
L_yakc_29:
	mov	sp, bp
	pop	bp
	ret
L_yakc_22:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_23
	ALIGN	2
YKRun:
	; >>>>> Line:	109
	; >>>>> { 
	jmp	L_yakc_31
L_yakc_32:
	; >>>>> Line:	110
	; >>>>> if (kernelStarted || !readyToStart) 
	mov	ax, word [kernelStarted]
	test	ax, ax
	jne	L_yakc_34
	mov	al, byte [readyToStart]
	test	al, al
	jne	L_yakc_33
L_yakc_34:
	; >>>>> Line:	111
	; >>>>> return; 
	jmp	L_yakc_35
L_yakc_33:
	; >>>>> Line:	114
	; >>>>> kernelStarted = 1; 
	mov	word [kernelStarted], 1
	; >>>>> Line:	116
	; >>>>> ) { 
	mov	byte [contextSaved], 0
	; >>>>> Line:	117
	; >>>>> YKScheduler(); 
	call	YKScheduler
	; >>>>> Line:	118
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_35:
	mov	sp, bp
	pop	bp
	ret
L_yakc_31:
	push	bp
	mov	bp, sp
	jmp	L_yakc_32
	ALIGN	2
YKScheduler:
	; >>>>> Line:	122
	; >>>>> { 
	jmp	L_yakc_37
L_yakc_38:
	; >>>>> Line:	127
	; >>>>> if (!kernelStarted) return; 
	mov	byte [bp-3], 100
	mov	byte [bp-4], 0
	; >>>>> Line:	127
	; >>>>> if (!kernelStarted) return; 
	mov	ax, word [kernelStarted]
	test	ax, ax
	jne	L_yakc_39
	; >>>>> Line:	127
	; >>>>> if (!kernelStarted) return; 
	jmp	L_yakc_40
L_yakc_39:
	; >>>>> Line:	129
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	131
	; >>>>> for (i = 0; i <= 5; ++i) 
	mov	word [bp-2], 0
	jmp	L_yakc_42
L_yakc_41:
	; >>>>> Line:	133
	; >>>>> if (!YKTCBArray[i].inUse) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_45
	; >>>>> Line:	134
	; >>>>> break; 
	jmp	L_yakc_43
L_yakc_45:
	; >>>>> Line:	135
	; >>>>> if (YKTCBArray[i].priority < maxPriority && YKTCBArray[i].state == READY) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	al, byte [si]
	cbw
	mov	dl, byte [bp-3]
	xor	dh, dh
	cmp	dx, ax
	jle	L_yakc_46
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	cmp	word [si], 3
	jne	L_yakc_46
	; >>>>> Line:	137
	; >>>>> maxPriority = YKTCBArray[i].priority; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	al, byte [si]
	mov	byte [bp-3], al
	; >>>>> Line:	138
	; >>>>> toRun = i; 
	mov	al, byte [bp-2]
	mov	byte [bp-4], al
L_yakc_46:
L_yakc_44:
	inc	word [bp-2]
L_yakc_42:
	cmp	word [bp-2], 5
	jle	L_yakc_41
L_yakc_43:
	; >>>>> Line:	141
	; >>>>> nextTask = &YKTCBArray[toRun]; 
	mov	al, byte [bp-4]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	word [nextTask], ax
	; >>>>> Line:	143
	; >>>>> if (runningTask == toRun && !firstTime) 
	mov	al, byte [bp-4]
	cmp	al, byte [runningTask]
	jne	L_yakc_47
	mov	al, byte [firstTime]
	test	al, al
	jne	L_yakc_47
	; >>>>> Line:	146
	; >>>>> return; 
	jmp	L_yakc_40
L_yakc_47:
	; >>>>> Line:	148
	; >>>>> if(firstTime) { 
	mov	al, byte [firstTime]
	test	al, al
	je	L_yakc_48
	; >>>>> Line:	149
	; >>>>> erISR() 
	mov	byte [firstTime], 0
	; >>>>> Line:	150
	; >>>>> currentTask = &YKTCBArray[toRun]; 
	mov	al, byte [bp-4]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	word [currentTask], ax
	; >>>>> Line:	151
	; >>>>> runningTask = toRun; 
	mov	al, byte [bp-4]
	mov	byte [runningTask], al
	; >>>>> Line:	152
	; >>>>> YKDispatcherFirst(); 
	call	YKDispatcherFirst
	jmp	L_yakc_49
L_yakc_48:
	; >>>>> Line:	156
	; >>>>> ++YKCtxSwCount; 
	inc	word [YKCtxSwCount]
	; >>>>> Line:	157
	; >>>>> currentTask = &YKTCBArray[runningTask]; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	word [currentTask], ax
	; >>>>> Line:	158
	; >>>>> runningTask = toRun; 
	mov	al, byte [bp-4]
	mov	byte [runningTask], al
	; >>>>> Line:	159
	; >>>>> if(contextSaved) 
	mov	al, byte [contextSaved]
	test	al, al
	je	L_yakc_50
	; >>>>> Line:	161
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	162
	; >>>>> YKDispatcherNoSave(); 
	call	YKDispatcherNoSave
	jmp	L_yakc_51
L_yakc_50:
	; >>>>> Line:	166
	; >>>>> YKDispatcher(); 
	call	YKDispatcher
L_yakc_51:
L_yakc_49:
L_yakc_40:
	mov	sp, bp
	pop	bp
	ret
L_yakc_37:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_38
	ALIGN	2
YKDelayTask:
	; >>>>> Line:	173
	; >>>>> { 
	jmp	L_yakc_53
L_yakc_54:
	; >>>>> Line:	174
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	176
	; >>>>> YKTCBArray[runningTask].delay = count; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 8
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	177
	; >>>>> YKTCBArray[runningTask].state = DELAYED; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 1
	; >>>>> Line:	178
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	179
	; >>>>> YKScheduler(); 
	call	YKScheduler
	; >>>>> Line:	181
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_53:
	push	bp
	mov	bp, sp
	jmp	L_yakc_54
	ALIGN	2
YKEnterISR:
	; >>>>> Line:	185
	; >>>>> { 
	jmp	L_yakc_56
L_yakc_57:
	; >>>>> Line:	186
	; >>>>> ++YKInterruptDepth; 
	inc	word [YKInterruptDepth]
	mov	sp, bp
	pop	bp
	ret
L_yakc_56:
	push	bp
	mov	bp, sp
	jmp	L_yakc_57
	ALIGN	2
YKExitISR:
	; >>>>> Line:	193
	; >>>>> { 
	jmp	L_yakc_59
L_yakc_60:
	; >>>>> Line:	194
	; >>>>> --YKInterruptDepth; 
	dec	word [YKInterruptDepth]
	; >>>>> Line:	198
	; >>>>> if(YKInterruptDepth == 0 && kernelStarted && readyToStart) 
	mov	ax, word [YKInterruptDepth]
	test	ax, ax
	jne	L_yakc_61
	mov	ax, word [kernelStarted]
	test	ax, ax
	je	L_yakc_61
	mov	al, byte [readyToStart]
	test	al, al
	je	L_yakc_61
	; >>>>> Line:	200
	; >>>>> contextSaved = 1; 
	mov	byte [contextSaved], 1
	; >>>>> Line:	201
	; >>>>> YKScheduler(); 
	call	YKScheduler
L_yakc_61:
	mov	sp, bp
	pop	bp
	ret
L_yakc_59:
	push	bp
	mov	bp, sp
	jmp	L_yakc_60
	ALIGN	2
YKTickHandler:
	; >>>>> Line:	206
	; >>>>> { 
	jmp	L_yakc_63
L_yakc_64:
	; >>>>> Line:	208
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	209
	; >>>>> ++YKTickNum; 
	inc	word [YKTickNum]
	; >>>>> Line:	210
	; >>>>> for (i = 1; i <= 5; ++i) { 
	mov	word [bp-2], 1
	jmp	L_yakc_66
L_yakc_65:
	; >>>>> Line:	211
	; >>>>> if(YKTCBArray[i].state == DELAYED) { 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	cmp	word [si], 1
	jne	L_yakc_69
	; >>>>> Line:	212
	; >>>>> if(YKTCBArray[i].delay == 1) { 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 8
	cmp	word [si], 1
	jne	L_yakc_70
	; >>>>> Line:	213
	; >>>>> YKTCBArray[i].state = READY; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 3
L_yakc_70:
	; >>>>> Line:	215
	; >>>>> --YKTCBArray[i].delay; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 8
	dec	word [si]
L_yakc_69:
L_yakc_68:
	inc	word [bp-2]
L_yakc_66:
	cmp	word [bp-2], 5
	jle	L_yakc_65
L_yakc_67:
	mov	sp, bp
	pop	bp
	ret
L_yakc_63:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_64
	ALIGN	2
YKSemCreate:
	; >>>>> Line:	225
	; >>>>> { 
	jmp	L_yakc_72
L_yakc_73:
	; >>>>> Line:	226
	; >>>>> if(semIndex < (5 + 5 + 5)) 
	cmp	word [semIndex], 15
	jae	L_yakc_74
	; >>>>> Line:	228
	; >>>>> YKSemArray[semIndex] 
	mov	ax, word [semIndex]
	shl	ax, 1
	mov	si, ax
	add	si, YKSemArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	229
	; >>>>> semIndex = semIndex + 1; 
	mov	ax, word [semIndex]
	inc	ax
	mov	word [semIndex], ax
	; >>>>> Line:	230
	; >>>>> return &YKSemArray[semIndex-1]; 
	mov	ax, word [semIndex]
	dec	ax
	shl	ax, 1
	add	ax, YKSemArray
	jmp	L_yakc_75
L_yakc_74:
	; >>>>> Line:	232
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_75:
	mov	sp, bp
	pop	bp
	ret
L_yakc_72:
	push	bp
	mov	bp, sp
	jmp	L_yakc_73
	ALIGN	2
YKSemPend:
	; >>>>> Line:	236
	; >>>>> { 
	jmp	L_yakc_77
L_yakc_78:
	; >>>>> Line:	237
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	238
	; >>>>> if(semaphore->value <= 0) 
	mov	si, word [bp+4]
	cmp	word [si], 0
	jg	L_yakc_79
	; >>>>> Line:	240
	; >>>>> YKTCBArray[runningTask].state = SUSPENDED; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 2
	; >>>>> Line:	241
	; >>>>> YKTCBArray[runningTask].semaphore = semaphore; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	242
	; >>>>> semaphore->value = semaphore->value - 1; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	dec	ax
	mov	word [si], ax
	; >>>>> Line:	243
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	244
	; >>>>> YKScheduler(); 
	call	YKScheduler
	jmp	L_yakc_80
L_yakc_79:
	; >>>>> Line:	248
	; >>>>> semaphore->value = semaphore->value - 1; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	dec	ax
	mov	word [si], ax
L_yakc_80:
	; >>>>> Line:	250
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_77:
	push	bp
	mov	bp, sp
	jmp	L_yakc_78
	ALIGN	2
YKSemPost:
	; >>>>> Line:	254
	; >>>>> { 
	jmp	L_yakc_82
L_yakc_83:
	; >>>>> Line:	258
	; >>>>> YKEnterMutex(); 
	mov	byte [bp-3], 100
	mov	byte [bp-4], 0
	; >>>>> Line:	258
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	259
	; >>>>> for(i = 1; i <= 5; i++) 
	mov	word [bp-2], 1
	jmp	L_yakc_85
L_yakc_84:
	; >>>>> Line:	261
	; >>>>> if(!YKTCBArray[i].inUse) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_88
	; >>>>> Line:	263
	; >>>>> break; 
	jmp	L_yakc_86
L_yakc_88:
	; >>>>> Line:	265
	; >>>>> if(YKTCBArray[i].semaphore == semaphore && YKTCBArray[i].priority < maxPriority) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 10
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_89
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	al, byte [si]
	cbw
	mov	dl, byte [bp-3]
	xor	dh, dh
	cmp	dx, ax
	jle	L_yakc_89
	; >>>>> Line:	267
	; >>>>> toRun = i; 
	mov	al, byte [bp-2]
	mov	byte [bp-4], al
	; >>>>> Line:	268
	; >>>>> maxPriority = YKTCBArray[i].priority; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 6
	mov	al, byte [si]
	mov	byte [bp-3], al
L_yakc_89:
L_yakc_87:
	inc	word [bp-2]
L_yakc_85:
	cmp	word [bp-2], 5
	jle	L_yakc_84
L_yakc_86:
	; >>>>> Line:	271
	; >>>>> semaphore->value = semaphore->value + 1; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	inc	ax
	mov	word [si], ax
	; >>>>> Line:	272
	; >>>>> if(toRun <= 0) 
	mov	al, byte [bp-4]
	test	al, al
	jne	L_yakc_90
	; >>>>> Line:	274
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	275
	; >>>>> return; 
	jmp	L_yakc_91
L_yakc_90:
	; >>>>> Line:	277
	; >>>>> YKTCBArray[toRun].state = READY; 
	mov	al, byte [bp-4]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 3
	; >>>>> Line:	278
	; >>>>> YKTCBArray[toRun].semaphore = 0; 
	mov	al, byte [bp-4]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	279
	; >>>>> if(YKInterruptDepth <= 0) 
	mov	ax, word [YKInterruptDepth]
	test	ax, ax
	jne	L_yakc_92
	; >>>>> Line:	281
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	282
	; >>>>> YKScheduler(); 
	call	YKScheduler
L_yakc_92:
	; >>>>> Line:	284
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_91:
	mov	sp, bp
	pop	bp
	ret
L_yakc_82:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_83
	ALIGN	2
YKQCreate:
	; >>>>> Line:	293
	; >>>>> { 
	jmp	L_yakc_94
L_yakc_95:
	; >>>>> Line:	294
	; >>>>> if(qIndex < 5) 
	cmp	word [qIndex], 5
	jae	L_yakc_96
	; >>>>> Line:	296
	; >>>>> YKQArray[qIndex].start = start; 
	mov	ax, word [qIndex]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	297
	; >>>>> YKQArray[qIndex].headIndex = 0; 
	mov	ax, word [qIndex]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	; >>>>> Line:	298
	; >>>>> YKQArray[qIndex].tailIndex = 0; 
	mov	ax, word [qIndex]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	299
	; >>>>> YKQArray[qIndex].size = size; 
	mov	ax, word [qIndex]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	300
	; >>>>> YKQArray[qIndex].semaphore = YKSemCreate(0); 
	xor	ax, ax
	push	ax
	call	YKSemCreate
	add	sp, 2
	push	ax
	mov	ax, word [qIndex]
	mov	cx, 10
	imul	cx
	mov	dx, ax
	add	dx, YKQArray
	mov	si, dx
	add	si, 8
	pop	ax
	mov	word [si], ax
	; >>>>> Line:	301
	; >>>>> qIndex = qIndex + 1; 
	mov	ax, word [qIndex]
	inc	ax
	mov	word [qIndex], ax
	; >>>>> Line:	302
	; >>>>> return &YKQArray[qIndex-1]; 
	mov	ax, word [qIndex]
	dec	ax
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	jmp	L_yakc_97
L_yakc_96:
	; >>>>> Line:	304
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_97:
	mov	sp, bp
	pop	bp
	ret
L_yakc_94:
	push	bp
	mov	bp, sp
	jmp	L_yakc_95
	ALIGN	2
YKQFull:
	; >>>>> Line:	308
	; >>>>> { 
	jmp	L_yakc_99
L_yakc_100:
	; >>>>> Line:	309
	; >>>>> if((queue->headIndex == queue->tailIndex + 1) || ((queue->headIndex == 0) && (queue->tailIndex == queue->size - 1))) 
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	inc	ax
	mov	si, word [bp+4]
	add	si, 4
	mov	dx, word [si]
	cmp	dx, ax
	je	L_yakc_102
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_101
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	dec	ax
	mov	si, word [bp+4]
	add	si, 6
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_101
L_yakc_102:
	; >>>>> Line:	311
	; >>>>> return 1; 
	mov	ax, 1
	jmp	L_yakc_103
L_yakc_101:
	; >>>>> Line:	313
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_103:
	mov	sp, bp
	pop	bp
	ret
L_yakc_99:
	push	bp
	mov	bp, sp
	jmp	L_yakc_100
	ALIGN	2
YKQEmpty:
	; >>>>> Line:	317
	; >>>>> { 
	jmp	L_yakc_105
L_yakc_106:
	; >>>>> Line:	319
	; >>>>> if(queue->tailIndex == queue->headIndex) 
	mov	si, word [bp+4]
	add	si, 6
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_107
	; >>>>> Line:	321
	; >>>>> return 1; 
	mov	ax, 1
	jmp	L_yakc_108
L_yakc_107:
	; >>>>> Line:	323
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_108:
	mov	sp, bp
	pop	bp
	ret
L_yakc_105:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_106
	ALIGN	2
YKQPend:
	; >>>>> Line:	328
	; >>>>> { 
	jmp	L_yakc_110
L_yakc_111:
	; >>>>> Line:	330
	; >>>>> YKEnterMutex(); 
	mov	word [bp-2], 0
	; >>>>> Line:	330
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	331
	; >>>>> if(YKQEmpty(queue)) { 
	push	word [bp+4]
	call	YKQEmpty
	add	sp, 2
	test	ax, ax
	je	L_yakc_112
	; >>>>> Line:	333
	; >>>>> YKSemPend(queue->semaphore); 
	mov	si, word [bp+4]
	add	si, 8
	push	word [si]
	call	YKSemPend
	add	sp, 2
L_yakc_112:
	; >>>>> Line:	336
	; >>>>> returnVal = queue->start[queue->headIndex]; 
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	shl	ax, 1
	mov	si, ax
	mov	di, word [bp+4]
	add	si, word [di]
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	337
	; >>>>> queue->headIndex = (queue->headIndex + 1) % queue->size; 
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	inc	ax
	xor	dx, dx
	mov	si, word [bp+4]
	add	si, 2
	div	word [si]
	mov	ax, dx
	mov	si, word [bp+4]
	add	si, 4
	mov	word [si], ax
	; >>>>> Line:	343
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	344
	; >>>>> return returnVal; 
	mov	ax, word [bp-2]
L_yakc_113:
	mov	sp, bp
	pop	bp
	ret
L_yakc_110:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_111
L_yakc_115:
	DB	0
	ALIGN	2
YKQPost:
	; >>>>> Line:	349
	; >>>>> { 
	jmp	L_yakc_116
L_yakc_117:
	; >>>>> Line:	352
	; >>>>> YKEnterMutex(); 
	mov	byte [bp-1], 0
	; >>>>> Line:	352
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	353
	; >>>>> if(YKQFu 
	push	word [bp+4]
	call	YKQFull
	add	sp, 2
	test	ax, ax
	je	L_yakc_118
	; >>>>> Line:	354
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	355
	; >>>>> return 0; 
	xor	ax, ax
	jmp	L_yakc_119
L_yakc_118:
	; >>>>> Line:	357
	; >>>>> if(YKQEmpty(queue) && notFirst) { 
	push	word [bp+4]
	call	YKQEmpty
	add	sp, 2
	test	ax, ax
	je	L_yakc_120
	mov	al, byte [L_yakc_115]
	test	al, al
	je	L_yakc_120
	; >>>>> Line:	358
	; >>>>> wasEmpty = 1; 
	mov	byte [bp-1], 1
L_yakc_120:
	; >>>>> Line:	360
	; >>>>> notFirst = 1; 
	mov	byte [L_yakc_115], 1
	; >>>>> Line:	361
	; >>>>> queue->start[queue->tailIndex] = msg; 
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	shl	ax, 1
	mov	si, ax
	mov	di, word [bp+4]
	add	si, word [di]
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	367
	; >>>>> queue->tailIndex = (queue->tailIndex + 1) % queue->size; 
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	inc	ax
	xor	dx, dx
	mov	si, word [bp+4]
	add	si, 2
	div	word [si]
	mov	ax, dx
	mov	si, word [bp+4]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	369
	; >>>>> if(wasEmpty) { 
	mov	al, byte [bp-1]
	test	al, al
	je	L_yakc_121
	; >>>>> Line:	370
	; >>>>> YKSemPost(queue->semaphore); 
	mov	si, word [bp+4]
	add	si, 8
	push	word [si]
	call	YKSemPost
	add	sp, 2
L_yakc_121:
	; >>>>> Line:	373
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	374
	; >>>>> return 1; 
	mov	ax, 1
L_yakc_119:
	mov	sp, bp
	pop	bp
	ret
L_yakc_116:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_117
	ALIGN	2
YKEventCreate:
	; >>>>> Line:	384
	; >>>>> { 
	jmp	L_yakc_123
L_yakc_124:
	; >>>>> Line:	385
	; >>>>> if(eventIndex < 5) 
	cmp	word [eventIndex], 5
	jae	L_yakc_125
	; >>>>> Line:	387
	; >>>>> YKEventArray[eventIndex].flags = initialValue; 
	mov	ax, word [eventIndex]
	shl	ax, 1
	mov	si, ax
	add	si, YKEventArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	388
	; >>>>> eventIndex = eventIndex + 1; 
	mov	ax, word [eventIndex]
	inc	ax
	mov	word [eventIndex], ax
	; >>>>> Line:	389
	; >>>>> return &YKEventArray[eventIndex-1]; 
	mov	ax, word [eventIndex]
	dec	ax
	shl	ax, 1
	add	ax, YKEventArray
	jmp	L_yakc_126
L_yakc_125:
	; >>>>> Line:	391
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_126:
	mov	sp, bp
	pop	bp
	ret
L_yakc_123:
	push	bp
	mov	bp, sp
	jmp	L_yakc_124
L_yakc_128:
	DB	"flag ready",0xA,0
	ALIGN	2
flagReady:
	; >>>>> Line:	395
	; >>>>> { 
	jmp	L_yakc_129
L_yakc_130:
	; >>>>> Line:	396
	; >>>>> if( (int)event && ((event->flags & eventMask) == eventMask) || 
	mov	ax, word [bp+4]
	test	ax, ax
	je	L_yakc_133
	mov	si, word [bp+4]
	mov	ax, word [si]
	and	ax, word [bp+6]
	mov	dx, word [bp+6]
	cmp	dx, ax
	je	L_yakc_132
L_yakc_133:
	mov	si, word [bp+4]
	mov	ax, word [si]
	and	ax, word [bp+6]
	je	L_yakc_131
	mov	ax, word [bp+8]
	test	ax, ax
	jne	L_yakc_131
L_yakc_132:
	; >>>>> Line:	399
	; >>>>> printString("flag ready\n"); 
	mov	ax, L_yakc_128
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	400
	; >>>>> return 1; 
	mov	al, 1
	jmp	L_yakc_134
L_yakc_131:
	; >>>>> Line:	402
	; >>>>> return 0; 
	xor	al, al
L_yakc_134:
	mov	sp, bp
	pop	bp
	ret
L_yakc_129:
	push	bp
	mov	bp, sp
	jmp	L_yakc_130
	ALIGN	2
YKEventPend:
	; >>>>> Line:	406
	; >>>>> { 
	jmp	L_yakc_136
L_yakc_137:
	; >>>>> Line:	407
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	408
	; >>>>> if(flagReady(event, eventMask, waitMode)) { 
	push	word [bp+8]
	push	word [bp+6]
	push	word [bp+4]
	call	flagReady
	add	sp, 6
	test	al, al
	je	L_yakc_138
	; >>>>> Line:	409
	; >>>>> return event->flags; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	jmp	L_yakc_139
L_yakc_138:
	; >>>>> Line:	411
	; >>>>> YKTCBArray[runningTask].state = EVENT_SUSPEND; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 4
	; >>>>> Line:	412
	; >>>>> YKTCBArray[runningTask].event = event; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 18
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	413
	; >>>>> = 0; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 14
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	414
	; >>>>> YKTCBArray[runningTask].eventType = waitMode; 
	mov	al, byte [runningTask]
	xor	ah, ah
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 16
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	415
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	416
	; >>>>> YKScheduler(); 
	call	YKScheduler
	; >>>>> Line:	417
	; >>>>> return event->flags; 
	mov	si, word [bp+4]
	mov	ax, word [si]
L_yakc_139:
	mov	sp, bp
	pop	bp
	ret
L_yakc_136:
	push	bp
	mov	bp, sp
	jmp	L_yakc_137
	ALIGN	2
YKEventSet:
	; >>>>> Line:	421
	; >>>>> { 
	jmp	L_yakc_141
L_yakc_142:
	; >>>>> Line:	423
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	424
	; >>>>> event->flags = event->flags | eventMask; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	or	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	425
	; >>>>> for(i = 1; i <= 5; i++) 
	mov	word [bp-2], 1
	jmp	L_yakc_144
L_yakc_143:
	; >>>>> Line:	427
	; >>>>> if(!YKTCBArray[i].inUse) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 12
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_147
	; >>>>> Line:	429
	; >>>>> break; 
	jmp	L_yakc_145
L_yakc_147:
	; >>>>> Line:	431
	; >>>>> if(flagReady(YKTCBArray[i].event, YKTCBArray[i].flagMask, YKTCBArray[i].eventType)) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 16
	push	word [si]
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 14
	push	word [si]
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 18
	push	word [si]
	call	flagReady
	add	sp, 6
	test	al, al
	je	L_yakc_148
	; >>>>> Line:	433
	; >>>>> if((YKTCBArray[i].event == event)) 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 18
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_149
	; >>>>> Line:	435
	; >>>>> YKTCBArray[i].event = 0; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 18
	mov	word [si], 0
	; >>>>> Line:	436
	; >>>>> YKTCBArr 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 14
	mov	word [si], 0
	; >>>>> Line:	437
	; >>>>> YKTCBArray[i].state = READY; 
	mov	ax, word [bp-2]
	mov	cx, 20
	imul	cx
	add	ax, YKTCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 3
L_yakc_149:
L_yakc_148:
L_yakc_146:
	inc	word [bp-2]
L_yakc_144:
	cmp	word [bp-2], 5
	jle	L_yakc_143
L_yakc_145:
	; >>>>> Line:	441
	; >>>>> contextSaved = 0; 
	mov	byte [contextSaved], 0
	; >>>>> Line:	442
	; >>>>> YKScheduler(); 
	call	YKScheduler
	mov	sp, bp
	pop	bp
	ret
L_yakc_141:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_142
	ALIGN	2
YKEventReset:
	; >>>>> Line:	446
	; >>>>> { 
	jmp	L_yakc_151
L_yakc_152:
	; >>>>> Line:	447
	; >>>>> event->flags = event->flags & ~eventMask; 
	mov	ax, word [bp+6]
	not	ax
	mov	si, word [bp+4]
	and	ax, word [si]
	mov	word [si], ax
	mov	sp, bp
	pop	bp
	ret
L_yakc_151:
	push	bp
	mov	bp, sp
	jmp	L_yakc_152
	ALIGN	2
YKCtxSwCount:
	TIMES	2 db 0
YKIdleCount:
	TIMES	2 db 0
YKTickNum:
	TIMES	2 db 0
IdleStk:
	TIMES	512 db 0
currentTask:
	TIMES	2 db 0
nextTask:
	TIMES	2 db 0
YKTCBArray:
	TIMES	120 db 0
YKSemArray:
	TIMES	30 db 0
YKQArray:
	TIMES	50 db 0
YKEventArray:
	TIMES	10 db 0
